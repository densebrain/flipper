/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import React from "react"
import {Properties} from "csstype";

declare module "@material-ui/styles" {
  declare export {
    default as createGenerateClassName
  } from "@material-ui/styles/createGenerateClassName";

  declare export {
    default as createStyles
  } from "@material-ui/styles/createStyles";

  declare export {
    default as getThemeProps
  } from "@material-ui/styles/getThemeProps";

  declare export { default as install } from "@material-ui/styles/install";

  declare export { default as jssPreset } from "@material-ui/styles/jssPreset";

  declare export {
    default as makeStyles
  } from "@material-ui/styles/makeStyles";

  declare export { default as styled } from "@material-ui/styles/styled";

  declare export {
    default as StylesProvider
  } from "@material-ui/styles/StylesProvider";

  declare export {
    default as ThemeProvider
  } from "@material-ui/styles/ThemeProvider";

  declare export { default as useTheme } from "@material-ui/styles/useTheme";

  declare export {
    default as withStyles,
    StyleRules,
    WithStyles
  } from "@material-ui/styles/withStyles";

  declare export {
    default as withTheme,
    WithTheme
  } from "@material-ui/styles/withTheme";
}
declare module "@material-ui/styles/createGenerateClassName" {
  import type { GenerateId } from "jss";

  declare export interface GenerateClassNameOptions {
    dangerouslyUseGlobalCSS?: boolean;
    productionPrefix?: string;
    seed?: string;
  }
  declare export default function createGenerateClassName(
    options?: GenerateClassNameOptions
  ): GenerateId;
}
declare module "@material-ui/styles/createStyles" {
  import type {
    CSSProperties,
    StyleRules,
    ClassNameMap
  } from "@material-ui/styles/withStyles";

  /**
   * This function doesn't really "do anything" at runtime, it's just the identity
   * function. Its only purpose is to defeat TypeScript's type widening when providing
   * style rules to `withStyles` which are a function of the `Theme`.
   * @param styles a set of style mappings
   * @returns the same styles that were passed in
   */
  declare export default function createStyles<
    C: string,
    P: { [key: string]: any }
  >(
    styles: StyleRules<P, C>
  ): StyleRules<P, C>;
}
declare module "@material-ui/styles/getThemeProps" {
  import type { ComponentsPropsList } from "@material-ui/core/styles/props";

  import type { Theme } from "@material-ui/core";

  declare interface NamedParams<K: $Keys<ComponentsPropsList>> {
    name: K;
    props: $ElementType<ComponentsPropsList, K>;
    theme?: Theme;
  }
  declare export default function getThemeProps<
    Name: $Keys<ComponentsPropsList>
  >(
    params: NamedParams<Name>
  ): $ElementType<ComponentsPropsList, Name>;
}
declare module "@material-ui/styles/install" {
  declare export default function install(): void;
}
declare module "@material-ui/styles/jssPreset" {
  import type { JssOptions } from "jss";

  declare export default function jssPreset(): JssOptions;
}
declare module "@material-ui/styles/makeStyles" {
  import type {
    ClassKeyOfStyles,
    ClassNameMap,
    PropsOfStyles,
    Styles,
    WithStylesOptions
  } from "@material-ui/styles/withStyles";

  declare type IsAny<
    T
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;
  declare type Or<
    A,
    B,
    C = false
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;
  declare type And<
    A,
    B,
    C = true
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;

  /**
 * @internal check if a type is `{}`

1. false if the given type has any members
2. false if the type is `object` which is the only other type with no members
{} is a top type so e.g. `string extends {}` but not `string extends object`
3. false if the given type is `unknown`
 */
  declare export type IsEmptyInterface<T> = And<
    /* Flow doesn't support conditional types, use $Call utility type */ any,
    /* Flow doesn't support conditional types, use $Call utility type */ any,
    /* Flow doesn't support conditional types, use $Call utility type */ any
  >;

  /**
 * @internal If a style callback is given with `theme => stylesOfTheme` then typescript
infers `Props` to `any`.
If a static object is given with { ...members } then typescript infers `Props`
to `{}`.

So we require no props in `useStyles` if `Props` in `makeStyles(styles)` is
inferred to either `any` or `{}`
 */
  declare export type StylesRequireProps<
    S
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;

  /**
 * @internal `Props` are `any` either by explicit annotation or if there are no callbacks
from which the typechecker could infer a type so it falls back to `any`.
See the test cases for examples and implications of explicit `any` annotation
 */
  declare export type StylesHook<
    S: Styles<any, any>
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;
  declare export default function makeStyles<S: Styles<any, any>>(
    styles: S,
    options?: WithStylesOptions
  ): StylesHook<S>;
}
declare module "@material-ui/styles/styled" {
  import type { Omit, PropsOf } from "@material-ui/core";

  import type {
    CSSProperties,
    StyledComponentProps,
    Styles,
    WithStylesOptions
  } from "@material-ui/styles/withStyles";

  /**
   * @internal
   */
  declare export type ComponentCreator<C: React.ReactType> = <Theme>(
    styles: CSSProperties | ((theme: Theme) => CSSProperties),
    options?: WithStylesOptions
  ) => React.ComponentType<
    Omit<JSX.LibraryManagedAttributes<C, PropsOf<C>>, "classes" | "className"> &
      StyledComponentProps<"root"> & {
        className?: string
      }
  >;
  declare export interface StyledProps {
    className: string;
  }
  declare export default function styled<C: React.ReactType>(
    Component: C
  ): ComponentCreator<C>;
}
declare module "@material-ui/styles/StylesProvider" {
  import type { GenerateId, Jss } from "jss";

  declare interface StylesOptions {
    disableGeneration?: boolean;
    generateClassName?: GenerateId;
    jss?: Jss;
    sheetsCache?: {};
    sheetsManager?: {};
    sheetsRegistry?: {};
  }
  declare var StylesContext: React.Context<StylesOptions>;
  declare export type StylesProviderProps = {
    children: React.ReactNode
  } & StylesOptions;

  declare var StylesProvider: React.ComponentType<StylesProviderProps>;
  declare export default typeof StylesProvider;
}
declare module "@material-ui/styles/ThemeProvider" {
  import type { Theme } from "@material-ui/core";

  declare var ThemeContext: React.Context<Theme>;
  declare export interface ThemeProviderProps {
    children: React.ReactNode;
    theme: Theme | ((outerTheme: Theme) => Theme);
  }
  declare var ThemeProvider: React.ComponentType<ThemeProviderProps>;
  declare export default typeof ThemeProvider;
}
declare module "@material-ui/styles/useTheme" {
  declare export default function useTheme<T>(): T;
}
declare module "@material-ui/styles/withStyles" {
  import typeof * as React from "react";

  import type { Omit, PropInjector, PropsOf } from "@material-ui/core";

  import typeof * as CSS from "csstype";
  import type {Properties} from "csstype";

  import typeof * as JSS from "jss";

  declare export type CSSProperties = {
    [k: string]:
      | $ElementType<Properties<number | string>, $Keys<Properties<string | number>>>
      | CSSProperties
  } & Properties<number | string>;

  /**
   * This is basically the API of JSS. It defines a Map<string, CSS>,
   * where
   * - the `keys` are the class (names) that will be created
   * - the `values` are objects that represent CSS rules (`React.CSSProperties`).
   *
   * if only `CSSProperties` are matched `Props` are inferred to `any`
   */
  declare export type StyleRules<
    Props: { [key: string]: any },
    ClassKey: string = string
  > = Record<ClassKey, CSSProperties | ((props: Props) => CSSProperties)>;

  /**
   * @internal
   */
  declare export type StyleRulesCallback<
    Theme,
    Props: { [key: string]: any },
    ClassKey: string = string
  > = (theme: Theme) => StyleRules<Props, ClassKey>;
  declare export type Styles<Theme, Props: {}, ClassKey: string = string> =
    | StyleRules<Props, ClassKey>
    | StyleRulesCallback<Theme, Props, ClassKey>;
  declare export type WithStylesOptions = {
    flip?: boolean,
    withTheme?: boolean,
    name?: string
  } & JSS.StyleSheetFactoryOptions;

  declare export type ClassNameMap<ClassKey: string = string> = Record<
    ClassKey,
    string
  >;

  /**
   * @internal
   */
  declare export type ClassKeyInferable<Theme, Props: {}> =
    | string
    | Styles<Theme, Props>;
  declare export type ClassKeyOfStyles<
    S
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;

  /**
   * infers the type of the theme used in the styles
   */
  declare export type PropsOfStyles<
    S
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;

  /**
   * infers the type of the props used in the styles
   */
  declare export type ThemeOfStyles<
    S
  > = /* Flow doesn't support conditional types, use $Call utility type */ any;
  declare export type WithStyles<
    S: ClassKeyInferable<any, any>,
    IncludeTheme: boolean | void = false
  > = /* Flow doesn't support conditional types, use $Call utility type */ any & {
    classes: ClassNameMap<ClassKeyOfStyles<S>>,
    innerRef?: React.Ref<any> | React.RefObject<any>
  } & PropsOfStyles<S>;
  declare export interface StyledComponentProps<ClassKey: string = string> {
    classes?: $Shape<ClassNameMap<ClassKey>>;
    innerRef?: React.Ref<any> | React.RefObject<any>;
  }
  declare export default function withStyles<
    S: Styles<any, any>,
    Options: WithStylesOptions
  >(
    style: S,
    options?: Options
  ): PropInjector<
    WithStyles<S, $PropertyType<Options, "withTheme">>,
    StyledComponentProps<ClassKeyOfStyles<S>>
  >;
}
declare module "@material-ui/styles/withTheme" {
  import type { PropInjector } from "@material-ui/core";

  declare export interface WithTheme<Theme> {
    theme: Theme;
    innerRef?: React.Ref<any>;
  }
  declare export default function withTheme<Theme>(): PropInjector<
    WithTheme<Theme>,
    $Shape<WithTheme<Theme>>
  >;
}
