/*
 * Copyright 2014-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.nio.file.Files
import java.nio.file.Paths
//import java.io.FileOutputStream
import java.util.zip.ZipFile
//import com.jfrog.bintray.gradle.tasks.BintrayUploadTask
//
//buildscript {
//    repositories {
//        google()
//        jcenter()
//        gradlePluginPortal()
//        mavenCentral()
//    }
//    dependencies {
//        classpath 'com.android.tools.build:gradle:3.5.0-alpha10'
//        classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.4"
//    }
//}

// Android tasks for Javadoc and sources.jar generation

//afterEvaluate {
    android {
        if (POM_PACKAGING == 'aar') {
            def androidJavadoc = tasks.create("androidJavadoc", Javadoc) {
                dependsOn("assembleDebug")
                source += files(android.sourceSets.main.java.srcDirs)
                failOnError false
                // This task will try to compile *everything* it finds in the above directory and
                // will choke on text files it doesn't understand.
                exclude '**/BUCK'
                exclude '**/*.md'
            }

            def androidJavadocJar = tasks.create("androidJavadocJar", Jar) {
                dependsOn("androidJavadoc")
                classifier = 'javadoc'
                from androidJavadoc.destinationDir
            }

            task androidSourcesJar(type: Jar) {
                classifier = 'sources'
                from android.sourceSets.main.java.srcDirs
            }

//            Upload upload = tasks.getByName("uploadArchives")
//            upload.artifacts.each { artifact ->
//                logger.quiet("artifact: ${artifact.javaClass.getName()}")
//            }
//            def deployers = upload.repositories//.withType(MavenDeployer)
//            logger.quiet("Deployers: ${deployers}")

//            tasks.getByName("bintrayUpload") {
//                dependsOn("bundleReleaseAar",androidJavadocJar,androidSourcesJar)
//                doFirst {
////                    Upload upload = tasks.getByName("upload")
////                    def artifacts = upload.artifacts
////                    logger.quiet("Deployers: ${artifacts}")
////                    def deployers = upload.repositories.withType(MavenDeployer)
////                    logger.quiet("Deployers: ${deployers}")
////                      .each { MavenDeployer deployer ->
////                        deployer.
////                    }
////                    PublishingExtension pub = extensions.getByType()
////                    def deployments = pub.publications.withType(MavenDeployment)
////                    deployments.each { signing.signPom(it) }
//                }
//            }

            libraryVariants.all { variant ->
                def name = variant.name.capitalize()

                def compileTaskProvider = variant.javaCompileProvider
                def compileJarTask = tasks.create("jar${name}", Jar) {
                    dependsOn(compileTaskProvider)
                }

                compileTaskProvider.configure { compileTask ->
                    compileJarTask.from(compileTask.destinationDir)


                    androidJavadoc.doFirst {
                        classpath += files(android.bootClasspath)
                        classpath += files(compileTask.classpath.files)
                        // This is generated by `assembleDebug` and holds the JARs generated by the APT.
                        classpath += fileTree(dir: "$buildDir/intermediates/bundles/debug/", include: '**/*.jar')

                        // Process AAR dependencies
                        def aarDependencies = classpath.filter { it.name.endsWith('.aar') }
                        classpath -= aarDependencies
                        aarDependencies.each { aar ->
                            // Extract classes.jar from the AAR dependency, and add it to the javadoc classpath
                            def outputPath = "$buildDir/tmp/aarJar/${aar.name.replace('.aar', '.jar')}"
                            classpath += files(outputPath)

                            // Use a task so the actual extraction only happens before the javadoc task is run

                            Task extractTask = tasks.create("extract${aar.name}") {
                                doLast {
                                    extractEntry(aar, 'classes.jar', outputPath)
                                }
                            }
                            androidJavadoc.dependsOn(extractTask)
                        }
                    }
                }
            }

            artifacts.add('archives', androidJavadocJar)
            artifacts.add('archives', androidSourcesJar)

            publishing.publications.all {
                artifact(androidJavadocJar)
                artifact(androidSourcesJar)
            }
        }


    if (POM_PACKAGING == 'jar') {
        def javadocJar = tasks.create(name: "javadocJar",type: Jar, dependsOn: javadoc) {
            classifier = 'javadoc'
            from javadoc.destinationDir
        }

        task sourcesJar(type: Jar, dependsOn: classes) {
            classifier = 'sources'
            from sourceSets.main.allSource
        }

        artifacts.add('archives', javadocJar)
        artifacts.add('archives', sourcesJar)
    }
        }


//}

// Utility method to extract only one entry in a zip file
private def extractEntry(archive, entryPath, outputPath) {
    if (!archive.exists()) {
        throw new GradleException("archive $archive not found")
    }

    def zip = new ZipFile(archive)
    zip.entries().each {
        if (it.name == entryPath) {
            def path = Paths.get(outputPath)
            if (!Files.exists(path)) {
                Files.createDirectories(path.getParent())
                Files.copy(zip.getInputStream(it), path)
            }
        }
    }
    zip.close()
}
